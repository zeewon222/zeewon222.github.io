import * as React from "react"
import { addPropertyControls, ControlType, RenderTarget, useTransform, motionValue, motion, animate } from "framer"
import { useEffect, useRef, useMemo } from "react"
import { isMotionValue } from "./lib/isMotionValue"
import { defaultEvents } from "./lib/constants"
import { useOnEnter } from "./lib/useOnNavigationTargetChange"
import { colorFromToken, colorTokentoValue } from "./lib/colorFromToken"

enum Indicators {
    Circle = "Circle",
    Line = "Line",
}

function getIndicator(indicator, props) {
    switch (indicator) {
        case Indicators.Circle:
            return <Circle {...props} />
        case Indicators.Line:
            return <Line {...props} />
        default:
            return <Line {...props} />
    }
}

export function Progress(props) {
    const {
        progress,
        progressEnd,
        onComplete,
        transition,
        type,
        padding,
        animateFromStart,
        shouldAnimate,
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseDown,
        onMouseUp,
    } = props
    const progressValue = isMotionValue(progress) ? progress : motionValue(progress * 0.01)
    const lastValue = useRef<number>(-1)
    const onCanvas = useMemo(() => RenderTarget.current() === RenderTarget.canvas, [])

    useOnEnter(() => {
        if (shouldAnimate && RenderTarget.current() !== RenderTarget.canvas) {
            if (animateFromStart) progressValue.set(0)
            if (!onCanvas) animate(progressValue, progressEnd * 0.01, transition)
        }
    })

    useEffect(
        () =>
            progressValue.onChange(() => {
                if (progressValue.get() >= 1 && progressValue.get() !== lastValue.current && onComplete) onComplete()
                lastValue.current = progressValue.get()
            }),
        []
    )

    return (
        <div
            {...{
                onClick,
                onMouseEnter,
                onMouseLeave,
                onMouseDown,
                onMouseUp,
            }}
            style={{
                width: "100%",
                height: "100%",
                padding,
                overflow: "hidden",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
            }}
        >
            {getIndicator(type, { ...props, progressValue })}
        </div>
    )
}

function Circle(props) {
    const { progressValue, strokeWidth, trackColor, progressColor, roundCap, width, height, padding } = props
    const circleSize = Math.min(width, height) - strokeWidth - padding * 2

    const xOffset = Math.abs(width - circleSize) / 2 - padding
    const yOffset = Math.abs(height - circleSize) / 2 - padding
    const w = circleSize
    const r = w / 2
    const c = Math.PI * w

    const dashOffset = useTransform(progressValue, [1, 0], [0, c])

    return (
        <motion.div
            style={{
                display: "block",
                width: "100%",
                height: "100%",
                rotate: roundCap ? -90 + 3 : -90,
            }}
        >
            <svg
                style={{
                    width: "100%",
                    height: "100%",
                }}
            >
                <g
                    style={{
                        transform: `translateX(${xOffset}px) translateY(${yOffset}px)`,
                    }}
                >
                    <circle
                        cx={r}
                        cy={r}
                        r={r}
                        fill="none"
                        stroke={colorTokentoValue(trackColor)}
                        strokeWidth={strokeWidth}
                        strokeDasharray={c}
                    />
                    <motion.circle
                        cx={r}
                        cy={r}
                        r={r}
                        fill="none"
                        stroke={colorTokentoValue(progressColor)}
                        strokeWidth={strokeWidth}
                        strokeLinecap={roundCap ? "round" : "butt"}
                        strokeDasharray={c}
                        style={{
                            strokeDashoffset: dashOffset,
                            transformOrigin: "center",
                        }}
                    />
                </g>
            </svg>
        </motion.div>
    )
}

function Line(props) {
    const { progressValue, lineHeight, trackColor, progressColor, borderRadius, roundCap } = props

    return (
        <motion.div
            style={{
                background: colorTokentoValue(trackColor),
                width: "100%",
                height: lineHeight,
                borderRadius,
                overflow: "hidden",
                z: 0.001,
            }}
        >
            <motion.div
                style={{
                    width: "100%",
                    height: lineHeight,
                    scaleX: progressValue,
                    background: colorTokentoValue(progressColor),
                    originX: 0,
                }}
            />
        </motion.div>
    )
}

Progress.defaultProps = {
    width: 50,
    height: 50,
    transition: { type: "tween", ease: [0, 0, 1, 1], duration: 1, delay: 0.25 },
    progressColor: "#09F",
    trackColor: "#E5E5E5",
    strokeWidth: 5,
    shouldAnimate: true,
    progress: 60,
    progressEnd: 100,
    padding: 5,
    strokeStyle: "solid",
    borderRadius: 5,
    lineHeight: 5,
    circleSize: 60,
    animateFromStart: false,
    type: Indicators.Circle,
}

addPropertyControls(Progress, {
    progress: {
        type: ControlType.Number,
        defaultValue: Progress.defaultProps.progress,
        unit: "%",
        min: 0,
        max: 100,
        title: "Value",
    },
    progressEnd: {
        type: ControlType.Number,
        defaultValue: Progress.defaultProps.progressEnd,
        unit: "%",
        min: 0,
        max: 100,
        title: "Animate To",
    },
    progressColor: {
        type: ControlType.Color,
        title: "Color",
        defaultValue: Progress.defaultProps.progressColor,
    },
    trackColor: {
        type: ControlType.Color,
        title: "Track",
        defaultValue: Progress.defaultProps.trackColor,
    },
    shouldAnimate: {
        type: ControlType.Boolean,
        title: "Animate",
        enabledTitle: "Yes",
        disabledTitle: "No",
    },
    animateFromStart: {
        type: ControlType.Boolean,
        title: "From",
        enabledTitle: "Start",
        disabledTitle: "Current",
        hidden: ({ shouldAnimate }) => !shouldAnimate,
    },
    transition: {
        title: "Animation",
        type: ControlType.Transition,
        defaultValue: Progress.defaultProps.transition,
        hidden: ({ shouldAnimate }) => !shouldAnimate,
    },
    type: {
        title: "Type",
        type: ControlType.Enum,
        options: Object.keys(Indicators).map(i => Indicators[i]),
    },
    padding: {
        type: ControlType.Number,
        title: "Padding",
        defaultValue: Progress.defaultProps.strokeWidth,
        displayStepper: true,
        min: 0,
    },
    strokeWidth: {
        type: ControlType.Number,
        title: "Thickness",
        defaultValue: Progress.defaultProps.strokeWidth,
        hidden: ({ type }) => type !== Indicators.Circle,
        displayStepper: true,
        min: 1,
    },
    lineHeight: {
        title: "Thickness",
        type: ControlType.Number,
        min: 1,
        hidden: ({ type }) => type !== Indicators.Line,
    },
    borderRadius: {
        type: ControlType.Number,
        title: "Radius",
        min: 0,
        max: 50,
        hidden: ({ type }) => type !== Indicators.Line,
    },

    roundCap: {
        type: ControlType.Boolean,
        hidden: ({ type }) => type !== Indicators.Circle,
        title: "Line Cap",
        enabledTitle: "Round",
        disabledTitle: "Flat",
    },
    onComplete: {
        type: ControlType.EventHandler,
    },
    ...defaultEvents,
})
