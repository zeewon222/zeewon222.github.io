import * as React from "react"
import { useRef, useEffect, useMemo } from "react"
import { ControlType, RenderTarget, addPropertyControls, FrameProps, Transition } from "framer"
import { cachedResponse, corsProxy, hashCode, checkForCachedData } from "./lib/video/Cache"
import { useOnEnter, useOnExit } from "./lib/useOnNavigationTargetChange"
import { defaultEvents } from "./lib/constants"
import { useIsBrowserSafari } from "./lib/isBrowserSafari"

/*
 ** VIDEO
 */

interface VideoProps extends Partial<FrameProps> {
    srcType: SrcType
    srcUrl: string
    srcFile: string
    poster: string
    autoPlay: boolean
    canvasPlay: boolean
    controls: boolean
    muted: boolean
    loop?: boolean
    loopType: LoopType
    fullLoop: boolean
    playsinline: boolean
    preload: PreloadType
    objectFit: ObjectFitType
    backgroundColor: string
    radius: number
    onEnd?: (Event: React.SyntheticEvent<HTMLElement>) => void
    onSeeked?: (Event: React.SyntheticEvent<HTMLElement>) => void
    onPause?: (Event: React.SyntheticEvent<HTMLElement>) => void
    onPlay?: (Event: React.SyntheticEvent<HTMLElement>) => void
    topLeft?: number
    topRight?: number
    bottomRight?: number
    bottomLeft?: number
    isMixed?: boolean
    onClick?: any
    onMouseEnter?: any
    onMouseLeave?: any
    onMouseDown?: any
    onMouseUp?: any
    startTime: number
    posterEnabled: boolean
    restartOnEnter: boolean
}

enum ObjectFitType {
    Fill = "fill",
    Contain = "contain",
    Cover = "cover",
    None = "none",
    ScaleDown = "scale-down",
}

enum LoopType {
    StartTime = "startTime",
    Beginning = "beginning",
    NoLoop = "noLoop",
}

enum PreloadType {
    None = "none",
    MetaData = "metadata",
    Auto = "auto",
    ForceCache = "force",
}

enum SrcType {
    Video = "Upload",
    Url = "URL",
}

// Reduce renders
function getProps(props: any): any {
    const { width, height, topLeft, topRight, bottomRight, bottomLeft, id, children, ...rest } = props
    return rest
}
export function Video(props) {
    const newProps = getProps(props)
    return <VideoMemo {...newProps} />
}

const VideoMemo = React.memo(function VideoInner(props: VideoProps) {
    const {
        srcType,
        srcFile,
        srcUrl,
        autoPlay,
        canvasPlay,
        loopType,
        muted,
        playsinline,
        controls,
        preload,
        objectFit,
        backgroundColor,
        radius,
        topLeft,
        topRight,
        bottomRight,
        bottomLeft,
        isMixed,
        onSeeked,
        onPause,
        onPlay,
        onEnd,
        onClick,
        onMouseEnter,
        onMouseLeave,
        onMouseDown,
        onMouseUp,
        poster,
        restartOnEnter,
        posterEnabled,
        startTime: startTimeProp,
    } = props

    // video elements behave oddly at 100% duration
    const startTime = startTimeProp === 100 ? 99.9 : startTimeProp
    const videoRef = useRef<HTMLVideoElement>()
    const isLoaded = useRef<boolean>(false)
    const isSafari = useIsBrowserSafari()
    const wasPausedOnLeave = useRef(null)
    const wasEndedOnLeave = useRef(null)

    const loop = loopType !== LoopType.NoLoop
    const fullLoop = loopType === LoopType.Beginning
    const isCanvas = RenderTarget.current() !== RenderTarget.preview
    const isForcedCache = preload === PreloadType.ForceCache
    const isAutoCache = preload === PreloadType.Auto
    const shouldPlay = !isCanvas || canvasPlay

    const restartVideo = (playAfter = true) => {
        if (!fullLoop) setProgress(startTime, playAfter)
        else if (videoRef.current) videoRef.current.play()
    }

    const setProgress = (progress, playAfter = false) => {
        if (videoRef.current) {
            const isAlreadySet =
                Math.abs(videoRef.current.currentTime - progress * 0.01 * videoRef.current.duration) < 0.3

            if (videoRef.current.duration > 0 && !isAlreadySet)
                videoRef.current.currentTime = progress * 0.01 * videoRef.current.duration

            if (autoPlay && shouldPlay && playAfter) videoRef.current.play()
        }
    }

    useEffect(() => {
        setProgress(startTime)
    }, [startTimeProp, srcFile, srcUrl])

    // Checking if we need to play on navigation enter
    useOnEnter(() => {
        if (wasPausedOnLeave.current === null) return

        if (videoRef.current) {
            if (restartOnEnter) restartVideo(!wasPausedOnLeave.current || wasEndedOnLeave.current)
            else if ((!wasEndedOnLeave && loop) || !wasPausedOnLeave.current) videoRef.current.play()
        }
    })

    // Pausing & saving playing state on navigation exit
    useOnExit(() => {
        if (videoRef.current) {
            wasEndedOnLeave.current = videoRef.current.ended
            wasPausedOnLeave.current = videoRef.current.paused
            videoRef.current.pause()
        }
    })

    const getUrl = (cors = false) => {
        if (props.srcType === SrcType.Url) {
            return cors ? corsProxy(props.srcUrl) : props.srcUrl
        }

        if (props.srcType === SrcType.Video) {
            return props.srcFile
        }
    }

    // Logic for cache options
    const setVideoRef = async element => {
        if (!element) return
        videoRef.current = element

        if (isSafari) {
            videoRef.current["src"] = getUrl()
            return
        }

        const { preload } = props

        if (preload === PreloadType.ForceCache) {
            if (isLoaded.current) return
            const url = getUrl(true)
            const response = await cachedResponse(url)
            if (response && videoRef.current) {
                videoRef.current["src"] = URL.createObjectURL(response) // IE10+
                isLoaded.current = true
            }
        } else if (preload === PreloadType.Auto) {
            if (isLoaded.current) return
            const url = getUrl(true)
            const response = await checkForCachedData(url)
            if (response && videoRef.current) videoRef.current["src"] = URL.createObjectURL(response)
            else videoRef.current["src"] = getUrl()
            isLoaded.current = true
        }
    }

    // Trigger rerender & reload when key props change
    useEffect(() => {
        isLoaded.current = false
        setVideoRef(videoRef.current)
    }, [srcFile, srcUrl, srcType, posterEnabled, canvasPlay, preload, loop, autoPlay])

    // Autoplay via JS to work in Safari
    useEffect(() => {
        if (isSafari && videoRef.current && autoPlay) {
            setTimeout(() => {
                videoRef.current.play()
            }, 50)
        }
    }, [])

    const key = useMemo(
        () =>
            hashCode(
                JSON.stringify({
                    srcType,
                    srcUrl,
                    srcFile,
                    autoPlay,
                    canvasPlay,
                    isForcedCache,
                })
            ),
        [srcType, srcUrl, srcFile, autoPlay, canvasPlay, isForcedCache]
    )

    const borderRadius = isMixed ? `${topLeft}px ${topRight}px ${bottomRight}px ${bottomLeft}px` : `${radius}px`

    return (
        <video
            autoPlay={autoPlay && shouldPlay}
            ref={setVideoRef}
            {...{
                onClick,
                onMouseEnter,
                onMouseLeave,
                onMouseDown,
                onMouseUp,
            }}
            key={key}
            poster={posterEnabled ? poster : undefined}
            style={{
                width: "100%",
                height: "100%",
                borderRadius,
                objectFit: objectFit,
                backgroundColor: backgroundColor,
                objectPosition: "50% 50%",
            }}
            onSeeked={e => {
                if (onSeeked) onSeeked(e)
            }}
            onPause={e => {
                if (onPause) onPause(e)
            }}
            onPlay={e => {
                if (onPlay) onPlay(e)
            }}
            onEnded={e => {
                if (onEnd) onEnd(e)
                if (loop && shouldPlay && videoRef.current) restartVideo()
            }}
            onCanPlay={() => {
                if (shouldPlay && videoRef.current && autoPlay) videoRef.current.play()
                else videoRef.current.pause()
                setProgress(startTime)
            }}
            src={(isForcedCache || isAutoCache) && !isSafari ? null : getUrl()}
            controls={isCanvas ? false : controls}
            muted={isCanvas ? true : muted}
            playsInline={playsinline}
        />
    )
})

Video.defaultProps = {
    srcType: SrcType.Url,
    srcUrl: "https://assets.mixkit.co/videos/preview/mixkit-a-man-paddling-on-a-board-near-the-seashore-1578-small.mp4",
    srcFile: "",
    posterEnabled: true,
    poster: "https://mixkit.imgix.net/videos/preview/mixkit-a-man-paddling-on-a-board-near-the-seashore-1578-0.jpg",
    controls: false,
    autoPlay: true,
    canvasPlay: false,
    fullLoop: false,
    muted: true,
    playsinline: true,
    restartOnEnter: false,
    preload: PreloadType.Auto,
    objectFit: ObjectFitType.Cover,
    backgroundColor: "rgba(0,0,0,0)",
    radius: 0,
    startTime: 0,
}

addPropertyControls(Video, {
    srcType: {
        type: ControlType.SegmentedEnum,
        title: "Source",
        options: [SrcType.Url, SrcType.Video],
    },
    srcUrl: {
        type: ControlType.String,
        title: " ",
        placeholder: ".../example.mp4",
        hidden(props) {
            return props.srcType === SrcType.Video
        },
    },

    srcFile: {
        type: ControlType.File,
        title: " ",
        allowedFileTypes: ["mp4"],
        hidden(props) {
            return props.srcType === SrcType.Url
        },
    },
    posterEnabled: {
        type: ControlType.Boolean,
        title: "Poster",
        enabledTitle: "Yes",
        disabledTitle: "No",
    },
    poster: {
        type: ControlType.Image,
        title: " ",
        hidden: ({ posterEnabled }) => !posterEnabled,
    },
    backgroundColor: {
        type: ControlType.Color,
        title: "Background",
    },
    radius: {
        title: "Radius",
        type: ControlType.FusedNumber,
        toggleKey: "isMixed",
        toggleTitles: ["Radius", "Radius per corner"],
        valueKeys: ["topLeft", "topRight", "bottomRight", "bottomLeft"],
        valueLabels: ["TL", "TR", "BR", "BL"],
        min: 0,
    },
    startTime: {
        title: "Start Time",
        type: ControlType.Number,
        min: 0,
        max: 100,
        step: 0.1,
        unit: "%",
    },
    loopType: {
        type: ControlType.Enum,
        title: "Loop",
        optionTitles: ["From Start Time", "From Beginning", "Don't Loop"],
        options: [LoopType.StartTime, LoopType.Beginning, LoopType.NoLoop],
    },
    objectFit: {
        type: ControlType.Enum,
        title: "Fit",
        options: [
            ObjectFitType.Cover,
            ObjectFitType.Fill,
            ObjectFitType.Contain,
            ObjectFitType.ScaleDown,
            ObjectFitType.None,
        ],
    },
    autoPlay: {
        type: ControlType.Boolean,
        title: "Auto Play",
        enabledTitle: "Yes",
        disabledTitle: "No",
    },
    canvasPlay: {
        type: ControlType.Boolean,
        title: "On Canvas",
        enabledTitle: "Play",
        disabledTitle: "Pause",
        hidden(props) {
            return props.autoPlay === false
        },
    },
    restartOnEnter: {
        type: ControlType.Boolean,
        title: "On ReEnter",
        enabledTitle: "Restart",
        disabledTitle: "Resume",
    },
    controls: {
        type: ControlType.Boolean,
        title: "Controls",
        enabledTitle: "Show",
        disabledTitle: "Hide",
    },

    muted: {
        type: ControlType.Boolean,
        title: "Muted",
        enabledTitle: "Yes",
        disabledTitle: "No",
    },
    // playsinline: { type: ControlType.Boolean, title: "Inline", enabledTitle: "Yes", disabledTitle: "No" },
    preload: {
        type: ControlType.Enum,
        title: "Cache",
        options: [PreloadType.Auto, PreloadType.None, PreloadType.ForceCache],
    },
    onEnd: { type: ControlType.EventHandler },
    onSeeked: { type: ControlType.EventHandler },
    onPause: { type: ControlType.EventHandler },
    onPlay: { type: ControlType.EventHandler },
    ...defaultEvents,
})
