import * as React from "react"
import { useEffect, useState } from "react"
import {
    Stack,
    addPropertyControls,
    ControlType,
    Scroll,
    ScrollProps,
    StackProperties,
    Frame,
} from "framer"
import { PreventLayoutIdGeneration } from "./LayoutIdPrevention"

VerticalAirtable.defaultProps = {
    width: 375,
    height: 810,
    onItemTapped: () => {},
}

type Props = {
    component: any
    width?: number
    height?: number
    url: string
    debug?: boolean
    image: string
    backgroundColor: string
    onItemTapped: (index: number, record: any) => void
} & StackProperties &
    ScrollProps

// converts Airtable fields to a format that Framer understands
const normalizeFields = (fields: any, props: Props) => {
    const result = {}

    for (const key of Object.keys(fields)) {
        const value = fields[key]
        // string fields are passed as-is
        if (typeof value === "string" || typeof value === "number") {
            result[key] = String(value)
        }
        // if there is a photo field, extract the first photo's URL
        if (Array.isArray(value) && value.length > 0 && !!value[0].thumbnails) {
            result[key] = value[0]["thumbnails"][props.image]["url"]
        }
    }

    return result
}

const isAirtableUrl = (url?: string): boolean => {
    if (!!url) {
        return url.startsWith("https://api.airtable.com/")
    } else {
        return false
    }
}

const isValidComponent = (component?: any): boolean => {
    if (!!component) {
        return !!component[0]
    } else {
        return false
    }
}

const ComponentInstructions: React.SFC = ({ children }) => {
    return (
        <div
            style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flexDirection: "column",
                width: "100%",
                height: "100%",
                fontSize: 15,
                fontWeight: 500,
                textAlign: "left",
                color: "#bb88ff",
                backgroundColor: "#2f2546",
                border: "1px solid #8855ff",
                padding: 20,
                paddingRight: 22,
                overflow: "hidden",
            }}
        >
            {children}
        </div>
    )
}

export function VerticalAirtable(props: Props) {
    const { component, url, debug, onItemTapped, ...rest } = props

    // if no data, show this text (instructions)

    if (!isAirtableUrl(props.url) || !isValidComponent(props.component)) {
        return (
            <ComponentInstructions>
                <h3>Instructions ðŸ”Ž </h3>
                <ol style={{ lineHeight: 2 }}>
                    <li>
                        <b>Create a design component</b>:<br />
                        Enable the layers to be overriden. Make sure you name
                        the design overrides the same as the columns you want to
                        retrieve from your data base.{" "}
                        <i>
                            Note: Names cannot contain spaces and are case
                            sensitive
                        </i>
                    </li>
                    <br />
                    <li>
                        <b>
                            {isAirtableUrl(props.url) ? "âœ…" : ""} Add Airtable
                            URL
                        </b>
                        : <br />
                        Enter your Airtable API url on the componentâ€™s
                        properties section. Learn more about how to get the link
                        here: airtable.com/api
                    </li>
                    <br />
                    <li>
                        <b>
                            {isValidComponent(props.component) ? "âœ…" : ""}{" "}
                            Connect the Airtable component to your design
                            component âœ¨
                        </b>
                    </li>
                </ol>
            </ComponentInstructions>
        )
    }

    const log = (...args: any[]) => {
        if (debug) {
            console.log(...args)
        }
    }

    // [1] State object using the useState hook.
    const [items, setItems] = useState<any>([])

    // [2] Define an async function that will request our data from an API endpoint, wait for the data to arrive, and then set a new state that includes the data.
    const fetchData = async (endpoint) => {
        const response = await fetch(endpoint)
        const json = await response.json()
        setItems(json.records)
    }

    // [3] Call our async function from a useEffect hook. This ensures that we only call the function once, when the component mounts, and not every time the component renders.
    useEffect(() => {
        fetchData(url)
    }, [url])

    // [4] From the result we want to get directly to the data contained in "show" and map the data to my card.
    return (
        <Scroll {...rest}>
            <Stack {...rest} size="100%" height="100%">
                <PreventLayoutIdGeneration>
                    {items.map((record, index) => {
                        const { fields } = record

                        log("Rendering component with fields", fields)

                        const ItemComponent = React.cloneElement(
                            props.component[0],
                            {
                                key: index,
                                ...normalizeFields(fields, props),
                                id: `${props.id}-${index}`,
                                background: props.backgroundColor,
                                width: "100%",
                                onTap: () => {
                                    onItemTapped(index, record)
                                },
                            }
                        )

                        return ItemComponent
                    })}
                </PreventLayoutIdGeneration>
            </Stack>
        </Scroll>
    )
}

//@ts-ignore
const StackControls = { ...Stack.propertyControls }
StackControls.distribution.defaultValue = "start"
StackControls.direction.defaultValue = "vertical"

//@ts-ignore
const ScrollControls = { ...Scroll.propertyControls }
ScrollControls.direction.defaultValue = "vertical"

addPropertyControls(VerticalAirtable, {
    //ControlType.String is displayed as an input field with an optional placeholder value
    url: {
        type: ControlType.String,
        placeholder:
            "https://api.airtable.com/v0/appJuy4S2EAMijkNg/Colors?api_key=keyQL4Up7cLcFgVUs",
        defaultValue: "",
        title: "Airtable URL",
    },
    component: {
        type: ControlType.ComponentInstance,
        title: "Design Component",
    },
    image: {
        type: ControlType.Enum,
        title: "Image Size",
        defaultValue: "large",
        options: ["small", "large", "full"],
        optionTitles: ["Small", "Large", "Full"],
    },
    //do we need it?
    // debug: {
    //     type: ControlType.Boolean,
    //     defaultValue: false,
    //     title: "Debug Mode",
    // },
    onItemTapped: {
        type: ControlType.EventHandler,
    },
    ...StackControls,
})
